# gateway/schema.graphql

type Query {
    # Queries del servicio de Reseñas
    searchBooks(query: String!): [Book!]
    book(id: ID!): Book
    reviewsForBook(bookId: String!): [Review!]
    myReviews: [Review!]

    # Queries del servicio de Usuarios
    me: UserProfile
    userProfile(userId: Int!): UserPublicProfile
    
    # Queries de Recomendaciones
    recommendations(level: Int): [Recommendation!]
    collaborativeRecommendations: [CollaborativeRecommendation!]
    myRatings: [BookRating!]
    
    # Queries del servicio de Web Scraping
    getBookPrices(bookTitle: String!): BookPricesResult!
    getAllScrapedBooks: ScrapedBooksResult!
}

type Mutation {
    # Mutaciones del servicio de Usuarios
    login(email: String!, password: String!): AuthPayload!
    register(
        email: String!, 
        password: String!, 
        firstName: String!, 
        lastName: String!, 
        description: String
    ): User!
    updateProfile(
        firstName: String
        lastName: String
        avatar: String
        bio: String
    ): UserProfile!
    
    # Mutaciones del servicio de Reseñas
    createReview(googleBookId: String!, content: String!, rating: Int!): Review!
    updateReview(id: ID!, content: String, rating: Int): Review!
    deleteReview(id: ID!): StatusResponse!
    
    # Mutaciones de Recomendaciones
    saveGenres(genres: [String!]!): GenreResponse!
    searchBook(
        bookId: String!
        title: String!
        authors: [String!]
        categories: [String!]
        publishedDate: String
        description: String
    ): SearchBookResponse!
    rateBook(bookId: String!, stars: Int!): RatingResponse!
    confirmPreferences: StatusResponse!
}

# --- Tipos de Datos ---

# Tipos del servicio de Usuarios
type AuthPayload {
    access: String!
    refresh: String!
}

type User {
    id: ID!
    email: String!
    first_name: String!
    last_name: String!
    has_selected_preferences: Boolean!
    preferred_genres: [String!]
}

type UserProfile {
    user: User!
    avatar: String
    bio: String
}

type UserPublicProfile {
    id: ID!
    first_name: String!
    last_name: String!
    date_joined: String!
    profile: PublicProfile!
}

type PublicProfile {
    avatar: String
    bio: String
}

# Tipos del servicio de Reseñas
type Book {
    id: ID!
    title: String
    authors: [String!]
    description: String
    thumbnail: String
    categories: [String!]
    publisher: String
    published_date: String
}

type Review {
    id: ID!
    user_id: String!
    google_book_id: String!
    content: String!
    rating: Int!
    karma_score: Int!
    created_at: String!
    updated_at: String!
    votes: [Vote!]
}

type Vote {
    voter_id: String!
    value: Int!
}

# Tipo genérico para respuestas de éxito/error
type StatusResponse {
    detail: String!
}

# Tipos para Recomendaciones
type Recommendation {
    bookId: String!
    title: String!
    authors: [String!]
    categories: [String!]
    publishedDate: String
    description: String
    avgRating: Float
    nRatings: Int
    reason: String
}

type CollaborativeRecommendation {
    bookId: String!
    title: String!
    authors: [String!]
    recommended_by_user: String
    because_both_rated_high: String
    similar_user_rating: Int!
    reason: String!
}

type BookRating {
    bookId: String!
    title: String!
    authors: [String!]
    stars: Int!
    timestamp: String
}

type GenreResponse {
    user_id: String!
    name: String
    saved_genres: [String!]!
}

type SearchBookResponse {
    user_id: String!
    bookId: String!
    title: String!
    authors: [String!]
    categories: [String!]
    registered: Boolean!
}

type RatingResponse {
    user_id: String!
    bookId: String!
    title: String
    authors: [String!]
    stars: Int!
    timestamp: String
    message: String
}

# Tipos para Web Scraping de precios
type BookPrice {
    id: ID!
    title: String!
    price: Float!
    source: String!
    scraped_at: String!
}

type BookPricesResult {
    book_title: String!
    prices: [BookPrice!]!
    status: String!
    message: String!
}

type ScrapedBooksResult {
    books: [BookPrice!]!
    count: Int!
    timestamp: String!
}